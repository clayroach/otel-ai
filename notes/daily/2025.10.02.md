---
id: daily-2025-10-02
title: '2025.10.02'
desc: 'AI Insights Critical Path Discovery: Phase 2 Interactive UI & Visualization'
updated: 1727876400000
created: 1727876400000
---

# Phase 2 - Interactive Critical Path UI & Visualization

**Date:** October 2, 2025
**Focus:** Phase 2a - Core Visualization Components
**Parent Feature:** #97 - AI Insights Critical Path Discovery
**Current Phase:** #173 - Interactive UI & Visualization

## Recent Accomplishments

### Phase 1 Backend Complete (PR #176) ✅
**Merged:** October 1, 2025

**Core Services Implemented:**
- `CriticalPathService`: Orchestration layer for automated path detection
- `InteractionAnalyzer`: Service interaction detection with span relationships
- `PathAnalysisService`: Multi-factor criticality scoring and ranking
- Strong TypeScript types with Error ADTs (CPError)

**LLM Integration:**
- Multi-model support (OpenAI GPT-4, Anthropic Claude 3.5)
- Configurable prompts for path analysis
- Structured JSON response parsing with validation
- Comprehensive error handling for LLM failures

**Data Persistence:**
- ClickHouse tables for analysis results
- Migration scripts for schema deployment
- Integration with existing OTLP data structures

**Testing:**
- Unit tests for core logic (>85% coverage)
- Integration tests with ClickHouse
- Fixture data for reproducible testing
- All tests passing

**Technical Highlights:**
- Effect-TS patterns throughout (Context/Layer/Schema)
- Clean separation: interaction detection → path scoring → LLM analysis
- Reusable components ready for Phase 2 UI integration

### Supporting Work
- PR #171: Fixed SQL model configuration for qwen/qwen3-coder-30b
- PR #169: Absolute time range support and replay endpoint validation
- PR #168: Disabled Claude automated code reviews
- PR #167: Database initialization fixes for LLM manager
- PR #166: Added qwen3-coder-30b and gemma-2b-it models

## Today's Goals: Phase 2a - Core Visualization

### 1. Critical Path Overlay Component
**File:** `ui/src/components/CriticalPath/CriticalPathOverlay.tsx`

**Requirements:**
- Visual highlighting of critical spans in trace waterfall
- Distinct visual treatment (color, thickness, glow effect)
- Integration with existing TraceView span tree structure
- Performance optimization for large traces (1000+ spans)

**Success Criteria:**
- Critical spans clearly distinguished from non-critical spans
- No performance degradation with complex traces
- Visual consistency with existing trace view style

### 2. Criticality Indicators
**File:** `ui/src/components/CriticalPath/CriticalityIndicator.tsx`

**Requirements:**
- Display criticality scores as visual badges/percentages
- Show criticality levels (high/medium/low) with color coding
- Tooltip with detailed criticality breakdown
- Responsive sizing for different span heights

**Success Criteria:**
- Scores visible at a glance
- Color coding intuitive (red=high, yellow=medium, green=low)
- Tooltips provide actionable context

### 3. Path Visibility Controls
**File:** `ui/src/components/CriticalPath/PathControls.tsx`

**Requirements:**
- Toggle critical path view on/off
- Filter by criticality threshold slider
- Service focus mode dropdown
- Expand/collapse sub-paths controls

**Success Criteria:**
- Toggle works instantly without flicker
- Filter updates smoothly (debounced)
- Controls are intuitive and discoverable

### 4. Backend API Integration
**Files:** `ui/src/api/critical-paths.ts`, `ui/src/hooks/useCriticalPaths.ts`

**Requirements:**
- REST API client for critical path data
- Type-safe request/response with proper schemas
- Error handling with user-friendly messages
- React Query integration for caching

**Success Criteria:**
- API calls properly typed and validated
- Loading states handled gracefully
- Errors displayed to user with retry options

## Implementation Approach

### Phase 2a: Core Visualization (Today)
1. **Setup Component Structure**
   - Create component files in `ui/src/components/CriticalPath/`
   - Define TypeScript interfaces for props
   - Setup React Query hooks for data fetching

2. **Implement Critical Path Overlay**
   - Extend existing TraceView waterfall rendering
   - Add visual highlighting logic
   - Implement color/thickness/glow effects

3. **Add Criticality Indicators**
   - Create badge/percentage components
   - Implement color coding logic
   - Add tooltip with detailed breakdown

4. **Build Path Controls**
   - Create toggle switch component
   - Implement threshold filter slider
   - Add service focus dropdown

5. **Connect to Backend**
   - Create API client with proper schemas
   - Setup React Query integration
   - Wire up components to data

### Technical Decisions
- **Visualization Library:** Reuse existing ECharts integration for consistency
- **State Management:** React Query for server state, local state for UI controls
- **Styling:** Maintain visual consistency with current TraceView style
- **Performance:** Memoization and virtual scrolling for large traces

## Success Metrics

**User Experience:**
- Critical paths identifiable in <5 seconds of viewing a trace
- Visual distinction between critical and non-critical spans is immediate
- Controls are discoverable without documentation

**Technical Quality:**
- No performance degradation with 1000+ span traces
- Zero runtime TypeScript errors
- All new components have >80% test coverage
- Mobile-responsive design

**Integration:**
- Seamless integration with existing TraceView
- No breaking changes to current trace visualization
- Reuses existing infrastructure (ECharts, span tree)

## Next Steps (Phase 2b & 2c)

**Phase 2b: AI Insights Integration** (Follow-up)
- AI insights panel with LLM analysis display
- Optimization suggestions from AI model
- Interaction pattern visualization

**Phase 2c: Real-time Updates** (Final)
- Live path updates via WebSocket/SSE
- Auto-refresh critical paths
- Notification system for new discoveries

## Dependencies

**Required:**
- ✅ Phase 1 backend (#176) - MERGED
- ✅ Existing TraceView component in ui package
- ✅ ECharts visualization library (integrated)

**Nice-to-have:**
- React Query v5 (already in use)
- Proper TypeScript types (already in use)
- Ant Design components (already in use)

## Risk Mitigation

**Potential Challenges:**
1. **Performance with Large Traces**
   - Mitigation: Virtual scrolling, memoization, debounced updates

2. **Visual Complexity**
   - Mitigation: Progressive disclosure, clear visual hierarchy

3. **API Integration**
   - Mitigation: Type-safe schemas, comprehensive error handling

4. **Mobile Responsiveness**
   - Mitigation: Responsive design from start, touch-friendly controls

## Definition of Done

**Phase 2a Complete When:**
- [x] API client created with proper types
- [x] React Query hooks implemented
- [x] Critical path highlighting integrated into TraceTimeline
- [x] showCriticalPath toggle wired up in TraceControls
- [x] Visual indicators (color, border, glow) implemented
- [x] Tooltip with severity information added
- [x] TypeScript unused parameter fixed
- [ ] Backend tested with real data
- [ ] All tests passing (unit + integration)
- [ ] Performance validated with large traces
- [ ] Visual QA complete (desktop + mobile)
- [ ] Documentation updated

## Today's Accomplishments

### Phase 2a: Core Visualization ✅ (90% Complete)

**Completed Tasks:**
1. ✅ Linked GitHub issues #119 and #173 with cross-reference comments
2. ✅ Created type-safe API client (`ui/src/api/critical-paths.ts`)
   - CriticalPath interface matching backend schema
   - getCriticalPaths() and checkHealth() functions
3. ✅ Implemented React Query hooks (`ui/src/hooks/useCriticalPaths.ts`)
   - useCriticalPaths() with caching and error handling
   - Helper hooks for filtering by severity, service, priority
4. ✅ Integrated critical path fetching into TraceView
   - Dynamic time range calculation (±30 min around trace)
   - Conditional fetching when showCriticalPath enabled
   - Loading/error states with visual feedback
5. ✅ Added critical path highlighting to TraceTimeline
   - Service-based severity mapping
   - Color-coded highlighting (red/orange/amber/yellow)
   - Border and glow effects for critical spans
   - Enhanced tooltip with severity percentage
6. ✅ ShowCriticalPath toggle already wired in TraceControls
   - ThunderboltOutlined icon
   - Triggers conditional API fetching
7. ✅ Fixed TypeScript unused parameter warning

**Technical Implementation:**
- Built on existing `feat/trace-view-echarts` branch foundation
- Leveraged existing TraceTimeline ECharts rendering
- Integrated with Phase 1 backend `/api/ai-insights/critical-paths` endpoint
- Used Map-based lookup for O(1) service→severity mapping
- Severity-based visual treatment:
  - ≥80%: Red (critical)
  - ≥60%: Orange (high)
  - ≥40%: Amber (medium)
  - <40%: Yellow (low)

**Remaining Tasks:**
- [ ] Backend testing with real topology data
- [ ] Unit tests for critical path components
- [ ] Performance validation with large traces
- [ ] Visual QA (desktop + mobile)

---

**Today's Focus:** Transform Phase 1 backend foundation into intuitive, interactive critical path visualization that helps developers understand distributed system behavior at a glance.
