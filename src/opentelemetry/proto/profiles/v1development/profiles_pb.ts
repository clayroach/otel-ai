// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.7.0 with parameter "target=ts,import_extension=js"
// @generated from file opentelemetry/proto/profiles/v1development/profiles.proto (package opentelemetry.proto.profiles.v1development, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { InstrumentationScope, KeyValue } from "../../common/v1/common_pb.js";
import { file_opentelemetry_proto_common_v1_common } from "../../common/v1/common_pb.js";
import type { Resource } from "../../resource/v1/resource_pb.js";
import { file_opentelemetry_proto_resource_v1_resource } from "../../resource/v1/resource_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file opentelemetry/proto/profiles/v1development/profiles.proto.
 */
export const file_opentelemetry_proto_profiles_v1development_profiles: GenFile = /*@__PURE__*/
  fileDesc("CjlvcGVudGVsZW1ldHJ5L3Byb3RvL3Byb2ZpbGVzL3YxZGV2ZWxvcG1lbnQvcHJvZmlsZXMucHJvdG8SKm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudCLuAwoSUHJvZmlsZXNEaWN0aW9uYXJ5EkoKDW1hcHBpbmdfdGFibGUYASADKAsyMy5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuTWFwcGluZxJMCg5sb2NhdGlvbl90YWJsZRgCIAMoCzI0Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5Mb2NhdGlvbhJMCg5mdW5jdGlvbl90YWJsZRgDIAMoCzI0Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5GdW5jdGlvbhJECgpsaW5rX3RhYmxlGAQgAygLMjAub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LkxpbmsSFAoMc3RyaW5nX3RhYmxlGAUgAygJEkAKD2F0dHJpYnV0ZV90YWJsZRgGIAMoCzInLm9wZW50ZWxlbWV0cnkucHJvdG8uY29tbW9uLnYxLktleVZhbHVlElIKD2F0dHJpYnV0ZV91bml0cxgHIAMoCzI5Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5BdHRyaWJ1dGVVbml0IrsBCgxQcm9maWxlc0RhdGESVwoRcmVzb3VyY2VfcHJvZmlsZXMYASADKAsyPC5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuUmVzb3VyY2VQcm9maWxlcxJSCgpkaWN0aW9uYXJ5GAIgASgLMj4ub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LlByb2ZpbGVzRGljdGlvbmFyeSK+AQoQUmVzb3VyY2VQcm9maWxlcxI7CghyZXNvdXJjZRgBIAEoCzIpLm9wZW50ZWxlbWV0cnkucHJvdG8ucmVzb3VyY2UudjEuUmVzb3VyY2USUQoOc2NvcGVfcHJvZmlsZXMYAiADKAsyOS5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuU2NvcGVQcm9maWxlcxISCgpzY2hlbWFfdXJsGAMgASgJSgYI6AcQ6QcirgEKDVNjb3BlUHJvZmlsZXMSQgoFc2NvcGUYASABKAsyMy5vcGVudGVsZW1ldHJ5LnByb3RvLmNvbW1vbi52MS5JbnN0cnVtZW50YXRpb25TY29wZRJFCghwcm9maWxlcxgCIAMoCzIzLm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5Qcm9maWxlEhIKCnNjaGVtYV91cmwYAyABKAkihgQKB1Byb2ZpbGUSSgoLc2FtcGxlX3R5cGUYASADKAsyNS5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuVmFsdWVUeXBlEkIKBnNhbXBsZRgCIAMoCzIyLm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5TYW1wbGUSGAoQbG9jYXRpb25faW5kaWNlcxgDIAMoBRISCgp0aW1lX25hbm9zGAQgASgDEhYKDmR1cmF0aW9uX25hbm9zGAUgASgDEkoKC3BlcmlvZF90eXBlGAYgASgLMjUub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LlZhbHVlVHlwZRIOCgZwZXJpb2QYByABKAMSGgoSY29tbWVudF9zdHJpbmRpY2VzGAggAygFEiEKGWRlZmF1bHRfc2FtcGxlX3R5cGVfaW5kZXgYCSABKAUSEgoKcHJvZmlsZV9pZBgKIAEoDBIgChhkcm9wcGVkX2F0dHJpYnV0ZXNfY291bnQYCyABKA0SHwoXb3JpZ2luYWxfcGF5bG9hZF9mb3JtYXQYDCABKAkSGAoQb3JpZ2luYWxfcGF5bG9hZBgNIAEoDBIZChFhdHRyaWJ1dGVfaW5kaWNlcxgOIAMoBSJGCg1BdHRyaWJ1dGVVbml0Eh4KFmF0dHJpYnV0ZV9rZXlfc3RyaW5kZXgYASABKAUSFQoNdW5pdF9zdHJpbmRleBgCIAEoBSIpCgRMaW5rEhAKCHRyYWNlX2lkGAEgASgMEg8KB3NwYW5faWQYAiABKAwingEKCVZhbHVlVHlwZRIVCg10eXBlX3N0cmluZGV4GAEgASgFEhUKDXVuaXRfc3RyaW5kZXgYAiABKAUSYwoXYWdncmVnYXRpb25fdGVtcG9yYWxpdHkYAyABKA4yQi5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuQWdncmVnYXRpb25UZW1wb3JhbGl0eSKxAQoGU2FtcGxlEh0KFWxvY2F0aW9uc19zdGFydF9pbmRleBgBIAEoBRIYChBsb2NhdGlvbnNfbGVuZ3RoGAIgASgFEg0KBXZhbHVlGAMgAygDEhkKEWF0dHJpYnV0ZV9pbmRpY2VzGAQgAygFEhcKCmxpbmtfaW5kZXgYBSABKAVIAIgBARIcChR0aW1lc3RhbXBzX3VuaXhfbmFubxgGIAMoBEINCgtfbGlua19pbmRleCLjAQoHTWFwcGluZxIUCgxtZW1vcnlfc3RhcnQYASABKAQSFAoMbWVtb3J5X2xpbWl0GAIgASgEEhMKC2ZpbGVfb2Zmc2V0GAMgASgEEhkKEWZpbGVuYW1lX3N0cmluZGV4GAQgASgFEhkKEWF0dHJpYnV0ZV9pbmRpY2VzGAUgAygFEhUKDWhhc19mdW5jdGlvbnMYBiABKAgSFQoNaGFzX2ZpbGVuYW1lcxgHIAEoCBIYChBoYXNfbGluZV9udW1iZXJzGAggASgIEhkKEWhhc19pbmxpbmVfZnJhbWVzGAkgASgIIrcBCghMb2NhdGlvbhIaCg1tYXBwaW5nX2luZGV4GAEgASgFSACIAQESDwoHYWRkcmVzcxgCIAEoBBI+CgRsaW5lGAMgAygLMjAub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LkxpbmUSEQoJaXNfZm9sZGVkGAQgASgIEhkKEWF0dHJpYnV0ZV9pbmRpY2VzGAUgAygFQhAKDl9tYXBwaW5nX2luZGV4IjwKBExpbmUSFgoOZnVuY3Rpb25faW5kZXgYASABKAUSDAoEbGluZRgCIAEoAxIOCgZjb2x1bW4YAyABKAMibgoIRnVuY3Rpb24SFQoNbmFtZV9zdHJpbmRleBgBIAEoBRIcChRzeXN0ZW1fbmFtZV9zdHJpbmRleBgCIAEoBRIZChFmaWxlbmFtZV9zdHJpbmRleBgDIAEoBRISCgpzdGFydF9saW5lGAQgASgDKowBChZBZ2dyZWdhdGlvblRlbXBvcmFsaXR5EicKI0FHR1JFR0FUSU9OX1RFTVBPUkFMSVRZX1VOU1BFQ0lGSUVEEAASIQodQUdHUkVHQVRJT05fVEVNUE9SQUxJVFlfREVMVEEQARImCiJBR0dSRUdBVElPTl9URU1QT1JBTElUWV9DVU1VTEFUSVZFEAJCpAEKLWlvLm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudEINUHJvZmlsZXNQcm90b1ABWjVnby5vcGVudGVsZW1ldHJ5LmlvL3Byb3RvL290bHAvcHJvZmlsZXMvdjFkZXZlbG9wbWVudKoCKk9wZW5UZWxlbWV0cnkuUHJvdG8uUHJvZmlsZXMuVjFEZXZlbG9wbWVudGIGcHJvdG8z", [file_opentelemetry_proto_common_v1_common, file_opentelemetry_proto_resource_v1_resource]);

/**
 * ProfilesDictionary represents the profiles data shared across the
 * entire message being sent.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesDictionary
 */
export type ProfilesDictionary = Message<"opentelemetry.proto.profiles.v1development.ProfilesDictionary"> & {
  /**
   * Mappings from address ranges to the image/binary/library mapped
   * into that address range referenced by locations via Location.mapping_index.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Mapping mapping_table = 1;
   */
  mappingTable: Mapping[];

  /**
   * Locations referenced by samples via Profile.location_indices.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Location location_table = 2;
   */
  locationTable: Location[];

  /**
   * Functions referenced by locations via Line.function_index.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Function function_table = 3;
   */
  functionTable: Function[];

  /**
   * Links referenced by samples via Sample.link_index.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Link link_table = 4;
   */
  linkTable: Link[];

  /**
   * A common table for strings referenced by various messages.
   * string_table[0] must always be "".
   *
   * @generated from field: repeated string string_table = 5;
   */
  stringTable: string[];

  /**
   * A common table for attributes referenced by various messages.
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attribute_table = 6;
   */
  attributeTable: KeyValue[];

  /**
   * Represents a mapping between Attribute Keys and Units.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.AttributeUnit attribute_units = 7;
   */
  attributeUnits: AttributeUnit[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesDictionary.
 * Use `create(ProfilesDictionarySchema)` to create a new message.
 */
export const ProfilesDictionarySchema: GenMessage<ProfilesDictionary> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 0);

/**
 * ProfilesData represents the profiles data that can be stored in persistent storage,
 * OR can be embedded by other protocols that transfer OTLP profiles data but do not
 * implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesData
 */
export type ProfilesData = Message<"opentelemetry.proto.profiles.v1development.ProfilesData"> & {
  /**
   * An array of ResourceProfiles.
   * For data coming from an SDK profiler, this array will typically contain one
   * element. Host-level profilers will usually create one ResourceProfile per
   * container, as well as one additional ResourceProfile grouping all samples
   * from non-containerized processes.
   * Other resource groupings are possible as well and clarified via
   * Resource.attributes and semantic conventions.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.ResourceProfiles resource_profiles = 1;
   */
  resourceProfiles: ResourceProfiles[];

  /**
   * One instance of ProfilesDictionary
   *
   * @generated from field: opentelemetry.proto.profiles.v1development.ProfilesDictionary dictionary = 2;
   */
  dictionary?: ProfilesDictionary;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesData.
 * Use `create(ProfilesDataSchema)` to create a new message.
 */
export const ProfilesDataSchema: GenMessage<ProfilesData> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 1);

/**
 * A collection of ScopeProfiles from a Resource.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ResourceProfiles
 */
export type ResourceProfiles = Message<"opentelemetry.proto.profiles.v1development.ResourceProfiles"> & {
  /**
   * The resource for the profiles in this message.
   * If this field is not set then no resource info is known.
   *
   * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
   */
  resource?: Resource;

  /**
   * A list of ScopeProfiles that originate from a resource.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.ScopeProfiles scope_profiles = 2;
   */
  scopeProfiles: ScopeProfiles[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_profiles" field which have their own schema_url field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ResourceProfiles.
 * Use `create(ResourceProfilesSchema)` to create a new message.
 */
export const ResourceProfilesSchema: GenMessage<ResourceProfiles> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 2);

/**
 * A collection of Profiles produced by an InstrumentationScope.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ScopeProfiles
 */
export type ScopeProfiles = Message<"opentelemetry.proto.profiles.v1development.ScopeProfiles"> & {
  /**
   * The instrumentation scope information for the profiles in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   *
   * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
   */
  scope?: InstrumentationScope;

  /**
   * A list of Profiles that originate from an instrumentation scope.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Profile profiles = 2;
   */
  profiles: Profile[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the profile data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to all profiles in the "profiles" field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ScopeProfiles.
 * Use `create(ScopeProfilesSchema)` to create a new message.
 */
export const ScopeProfilesSchema: GenMessage<ScopeProfiles> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 3);

/**
 * Represents a complete profile, including sample types, samples,
 * mappings to binaries, locations, functions, string table, and additional metadata.
 * It modifies and annotates pprof Profile with OpenTelemetry specific fields.
 *
 * Note that whilst fields in this message retain the name and field id from pprof in most cases
 * for ease of understanding data migration, it is not intended that pprof:Profile and
 * OpenTelemetry:Profile encoding be wire compatible.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Profile
 */
export type Profile = Message<"opentelemetry.proto.profiles.v1development.Profile"> & {
  /**
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;
   */
  sampleType: ValueType[];

  /**
   * The set of samples recorded in this profile.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Sample sample = 2;
   */
  sample: Sample[];

  /**
   * References to locations in ProfilesDictionary.location_table.
   *
   * @generated from field: repeated int32 location_indices = 3;
   */
  locationIndices: number[];

  /**
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   *
   * @generated from field: int64 time_nanos = 4;
   */
  timeNanos: bigint;

  /**
   * Duration of the profile, if a duration makes sense.
   *
   * @generated from field: int64 duration_nanos = 5;
   */
  durationNanos: bigint;

  /**
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   *
   * @generated from field: opentelemetry.proto.profiles.v1development.ValueType period_type = 6;
   */
  periodType?: ValueType;

  /**
   * The number of events between sampled occurrences.
   *
   * @generated from field: int64 period = 7;
   */
  period: bigint;

  /**
   * Free-form text associated with the profile. The text is displayed as is
   * to the user by the tools that read profiles (e.g. by pprof). This field
   * should not be used to store any machine-readable information, it is only
   * for human-friendly content. The profile must stay functional if this field
   * is cleaned.
   *
   * Indices into ProfilesDictionary.string_table.
   *
   * @generated from field: repeated int32 comment_strindices = 8;
   */
  commentStrindices: number[];

  /**
   * Index into the sample_type array to the default sample type.
   *
   * @generated from field: int32 default_sample_type_index = 9;
   */
  defaultSampleTypeIndex: number;

  /**
   * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
   * all zeroes is considered invalid.
   *
   * This field is required.
   *
   * @generated from field: bytes profile_id = 10;
   */
  profileId: Uint8Array;

  /**
   * dropped_attributes_count is the number of attributes that were discarded. Attributes
   * can be discarded because their keys are too long or because there are too many
   * attributes. If this value is 0, then no attributes were dropped.
   *
   * @generated from field: uint32 dropped_attributes_count = 11;
   */
  droppedAttributesCount: number;

  /**
   * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
   *
   * @generated from field: string original_payload_format = 12;
   */
  originalPayloadFormat: string;

  /**
   * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
   * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
   * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
   * If the original payload is in pprof format, it SHOULD not be included in this field.
   * The field is optional, however if it is present then equivalent converted data should be populated in other fields
   * of this message as far as is practicable.
   *
   * @generated from field: bytes original_payload = 13;
   */
  originalPayload: Uint8Array;

  /**
   * References to attributes in attribute_table. [optional]
   * It is a collection of key/value pairs. Note, global attributes
   * like server name can be set using the resource API. Examples of attributes:
   *
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "abc.com/myattribute": true
   *     "abc.com/score": 10.239
   *
   * The OpenTelemetry API specification further restricts the allowed value types:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   *
   * @generated from field: repeated int32 attribute_indices = 14;
   */
  attributeIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Profile.
 * Use `create(ProfileSchema)` to create a new message.
 */
export const ProfileSchema: GenMessage<Profile> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 4);

/**
 * Represents a mapping between Attribute Keys and Units.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.AttributeUnit
 */
export type AttributeUnit = Message<"opentelemetry.proto.profiles.v1development.AttributeUnit"> & {
  /**
   * Index into string table.
   *
   * @generated from field: int32 attribute_key_strindex = 1;
   */
  attributeKeyStrindex: number;

  /**
   * Index into string table.
   *
   * @generated from field: int32 unit_strindex = 2;
   */
  unitStrindex: number;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.AttributeUnit.
 * Use `create(AttributeUnitSchema)` to create a new message.
 */
export const AttributeUnitSchema: GenMessage<AttributeUnit> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 5);

/**
 * A pointer from a profile Sample to a trace Span.
 * Connects a profile sample to a trace span, identified by unique trace and span IDs.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Link
 */
export type Link = Message<"opentelemetry.proto.profiles.v1development.Link"> & {
  /**
   * A unique identifier of a trace that this linked span is part of. The ID is a
   * 16-byte array.
   *
   * @generated from field: bytes trace_id = 1;
   */
  traceId: Uint8Array;

  /**
   * A unique identifier for the linked span. The ID is an 8-byte array.
   *
   * @generated from field: bytes span_id = 2;
   */
  spanId: Uint8Array;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Link.
 * Use `create(LinkSchema)` to create a new message.
 */
export const LinkSchema: GenMessage<Link> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 6);

/**
 * ValueType describes the type and units of a value, with an optional aggregation temporality.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ValueType
 */
export type ValueType = Message<"opentelemetry.proto.profiles.v1development.ValueType"> & {
  /**
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 type_strindex = 1;
   */
  typeStrindex: number;

  /**
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 unit_strindex = 2;
   */
  unitStrindex: number;

  /**
   * @generated from field: opentelemetry.proto.profiles.v1development.AggregationTemporality aggregation_temporality = 3;
   */
  aggregationTemporality: AggregationTemporality;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ValueType.
 * Use `create(ValueTypeSchema)` to create a new message.
 */
export const ValueTypeSchema: GenMessage<ValueType> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 7);

/**
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Sample
 */
export type Sample = Message<"opentelemetry.proto.profiles.v1development.Sample"> & {
  /**
   * locations_start_index along with locations_length refers to to a slice of locations in Profile.location_indices.
   *
   * @generated from field: int32 locations_start_index = 1;
   */
  locationsStartIndex: number;

  /**
   * locations_length along with locations_start_index refers to a slice of locations in Profile.location_indices.
   * Supersedes location_index.
   *
   * @generated from field: int32 locations_length = 2;
   */
  locationsLength: number;

  /**
   * The type and unit of each value is defined by the corresponding
   * entry in Profile.sample_type. All samples must have the same
   * number of values, the same as the length of Profile.sample_type.
   * When aggregating multiple samples into a single sample, the
   * result has a list of values that is the element-wise sum of the
   * lists of the originals.
   *
   * @generated from field: repeated int64 value = 3;
   */
  value: bigint[];

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 4;
   */
  attributeIndices: number[];

  /**
   * Reference to link in ProfilesDictionary.link_table. [optional]
   *
   * @generated from field: optional int32 link_index = 5;
   */
  linkIndex?: number;

  /**
   * Timestamps associated with Sample represented in nanoseconds. These timestamps are expected
   * to fall within the Profile's time range. [optional]
   *
   * @generated from field: repeated uint64 timestamps_unix_nano = 6;
   */
  timestampsUnixNano: bigint[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Sample.
 * Use `create(SampleSchema)` to create a new message.
 */
export const SampleSchema: GenMessage<Sample> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 8);

/**
 * Describes the mapping of a binary in memory, including its address range,
 * file offset, and metadata like build ID
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Mapping
 */
export type Mapping = Message<"opentelemetry.proto.profiles.v1development.Mapping"> & {
  /**
   * Address at which the binary (or DLL) is loaded into memory.
   *
   * @generated from field: uint64 memory_start = 1;
   */
  memoryStart: bigint;

  /**
   * The limit of the address range occupied by this mapping.
   *
   * @generated from field: uint64 memory_limit = 2;
   */
  memoryLimit: bigint;

  /**
   * Offset in the binary that corresponds to the first mapped address.
   *
   * @generated from field: uint64 file_offset = 3;
   */
  fileOffset: bigint;

  /**
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   *
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 filename_strindex = 4;
   */
  filenameStrindex: number;

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 5;
   */
  attributeIndices: number[];

  /**
   * The following fields indicate the resolution of symbolic info.
   *
   * @generated from field: bool has_functions = 6;
   */
  hasFunctions: boolean;

  /**
   * @generated from field: bool has_filenames = 7;
   */
  hasFilenames: boolean;

  /**
   * @generated from field: bool has_line_numbers = 8;
   */
  hasLineNumbers: boolean;

  /**
   * @generated from field: bool has_inline_frames = 9;
   */
  hasInlineFrames: boolean;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Mapping.
 * Use `create(MappingSchema)` to create a new message.
 */
export const MappingSchema: GenMessage<Mapping> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 9);

/**
 * Describes function and line table debug information.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Location
 */
export type Location = Message<"opentelemetry.proto.profiles.v1development.Location"> & {
  /**
   * Reference to mapping in ProfilesDictionary.mapping_table.
   * It can be unset if the mapping is unknown or not applicable for
   * this profile type.
   *
   * @generated from field: optional int32 mapping_index = 1;
   */
  mappingIndex?: number;

  /**
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   *
   * @generated from field: uint64 address = 2;
   */
  address: bigint;

  /**
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   *
   * E.g., if memcpy() is inlined into printf:
   *    line[0].function_name == "memcpy"
   *    line[1].function_name == "printf"
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Line line = 3;
   */
  line: Line[];

  /**
   * Provides an indication that multiple symbols map to this location's
   * address, for example due to identical code folding by the linker. In that
   * case the line information above represents one of the multiple
   * symbols. This field must be recomputed when the symbolization state of the
   * profile changes.
   *
   * @generated from field: bool is_folded = 4;
   */
  isFolded: boolean;

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 5;
   */
  attributeIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 10);

/**
 * Details a specific line in a source code, linked to a function.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Line
 */
export type Line = Message<"opentelemetry.proto.profiles.v1development.Line"> & {
  /**
   * Reference to function in ProfilesDictionary.function_table.
   *
   * @generated from field: int32 function_index = 1;
   */
  functionIndex: number;

  /**
   * Line number in source code. 0 means unset.
   *
   * @generated from field: int64 line = 2;
   */
  line: bigint;

  /**
   * Column number in source code. 0 means unset.
   *
   * @generated from field: int64 column = 3;
   */
  column: bigint;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Line.
 * Use `create(LineSchema)` to create a new message.
 */
export const LineSchema: GenMessage<Line> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 11);

/**
 * Describes a function, including its human-readable name, system name,
 * source file, and starting line number in the source.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Function
 */
export type Function = Message<"opentelemetry.proto.profiles.v1development.Function"> & {
  /**
   * Function name. Empty string if not available.
   *
   * @generated from field: int32 name_strindex = 1;
   */
  nameStrindex: number;

  /**
   * Function name, as identified by the system. For instance,
   * it can be a C++ mangled name. Empty string if not available.
   *
   * @generated from field: int32 system_name_strindex = 2;
   */
  systemNameStrindex: number;

  /**
   * Source file containing the function. Empty string if not available.
   *
   * @generated from field: int32 filename_strindex = 3;
   */
  filenameStrindex: number;

  /**
   * Line number in source file. 0 means unset.
   *
   * @generated from field: int64 start_line = 4;
   */
  startLine: bigint;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Function.
 * Use `create(FunctionSchema)` to create a new message.
 */
export const FunctionSchema: GenMessage<Function> = /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 12);

/**
 * Specifies the method of aggregating metric values, either DELTA (change since last report)
 * or CUMULATIVE (total since a fixed start time).
 *
 * @generated from enum opentelemetry.proto.profiles.v1development.AggregationTemporality
 */
export enum AggregationTemporality {
  /**
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * * DELTA is an AggregationTemporality for a profiler which reports
   * changes since last report time. Successive metrics contain aggregation of
   * values from continuous and non-overlapping intervals.
   *
   * The values for a DELTA metric are based only on the time interval
   * associated with one measurement cycle. There is no dependency on
   * previous measurements like is the case for CUMULATIVE metrics.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * DELTA metric:
   *
   * 1. The system starts receiving at time=t_0.
   * 2. A request is received, the system measures 1 request.
   * 3. A request is received, the system measures 1 request.
   * 4. A request is received, the system measures 1 request.
   * 5. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+1 with a value of 3.
   * 6. A request is received, the system measures 1 request.
   * 7. A request is received, the system measures 1 request.
   * 8. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0+1 to
   * t_0+2 with a value of 2. 
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_DELTA = 1;
   */
  DELTA = 1,

  /**
   * * CUMULATIVE is an AggregationTemporality for a profiler which
   * reports changes since a fixed start time. This means that current values
   * of a CUMULATIVE metric depend on all previous measurements since the
   * start time. Because of this, the sender is required to retain this state
   * in some form. If this state is lost or invalidated, the CUMULATIVE metric
   * values MUST be reset and a new fixed start time following the last
   * reported measurement time sent MUST be used.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * CUMULATIVE metric:
   *
   * 1. The system starts receiving at time=t_0.
   * 2. A request is received, the system measures 1 request.
   * 3. A request is received, the system measures 1 request.
   * 4. A request is received, the system measures 1 request.
   * 5. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+1 with a value of 3.
   * 6. A request is received, the system measures 1 request.
   * 7. A request is received, the system measures 1 request.
   * 8. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+2 with a value of 5.
   * 9. The system experiences a fault and loses state.
   * 10. The system recovers and resumes receiving at time=t_1.
   * 11. A request is received, the system measures 1 request.
   * 12. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_1 to
   * t_1+1 with a value of 1.
   *
   * Note: Even though, when reporting changes since last report time, using
   * CUMULATIVE is valid, it is not recommended. 
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
   */
  CUMULATIVE = 2,
}

/**
 * Describes the enum opentelemetry.proto.profiles.v1development.AggregationTemporality.
 */
export const AggregationTemporalitySchema: GenEnum<AggregationTemporality> = /*@__PURE__*/
  enumDesc(file_opentelemetry_proto_profiles_v1development_profiles, 0);

