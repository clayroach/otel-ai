/**
 * Test fixtures for diagnostic query generation
 * These represent real-world queries generated by the LLM for testing
 */

export interface DiagnosticQueryFixture {
  id: string
  name: string
  description: string
  sql: string
  expectedServices: string[]
  analysisType: 'latency' | 'errors' | 'bottlenecks' | 'throughput' | 'general'
  model: string
}

/**
 * Checkout Flow Query - Real example from CodeLlama generation
 */
export const checkoutFlowQuery: DiagnosticQueryFixture = {
  id: 'checkout-flow',
  name: 'Checkout Flow Analysis',
  description: 'Analyze checkout service performance across payment and cart operations',
  sql: `SELECT 
    service_name,
    operation_name,
    toStartOfMinute(start_time) AS time_bucket,
    quantile(0.50)(duration_ns/1000000) AS p50_ms,
    quantile(0.95)(duration_ns/1000000) AS p95_ms,
    quantile(0.99)(duration_ns/1000000) AS p99_ms,
    count() AS request_count
FROM otel.traces
WHERE 
    service_name IN ('frontend', 'cart', 'checkout', 'payment', 'email')
    AND start_time >= now() - INTERVAL 15 MINUTE
GROUP BY 
    service_name,
    operation_name,
    time_bucket
HAVING 
    count() > 5
ORDER BY 
    service_name,
    operation_name,
    time_bucket`,
  expectedServices: ['frontend', 'cart', 'checkout', 'payment', 'email'],
  analysisType: 'latency',
  model: 'codellama'
}

/**
 * Product Search Flow Query - Real example from UI generation
 */
export const productSearchQuery: DiagnosticQueryFixture = {
  id: 'product-search',
  name: 'Product Search Flow',
  description: 'Analyze product search and recommendation service performance',
  sql: `SELECT 
    service_name, 
    operation_name, 
    count() AS request_count,
    count() / (15 * 60) AS requests_per_second,
    countIf(status_code = 'OK') / count() AS success_ratio,
    avg(duration_ns) / 1000000 AS avg_duration_ms,
    max(duration_ns) / 1000000 AS max_duration_ms
FROM otel.traces 
WHERE service_name IN ('frontend', 'product-catalog', 'recommendation', 'ad')
  AND start_time >= now() - INTERVAL 15 MINUTE
GROUP BY service_name, operation_name
ORDER BY request_count DESC`,
  expectedServices: ['frontend', 'product-catalog', 'recommendation', 'ad'],
  analysisType: 'throughput',
  model: 'codellama'
}

/**
 * Currency Conversion Flow Query - Real example from UI generation
 */
export const currencyConversionQuery: DiagnosticQueryFixture = {
  id: 'currency-conversion',
  name: 'Currency Conversion Flow',
  description: 'Analyze currency conversion service performance and success rates',
  sql: `SELECT 
    service_name,
    operation_name,
    count() AS request_count,
    count() / (15 * 60) AS requests_per_second,
    countIf(status_code = 'OK') / count() AS success_ratio,
    avg(duration_ns) / 1000000 AS avg_duration_ms
FROM otel.traces
WHERE 
    service_name IN ('frontend', 'currency', 'product-catalog')
    AND start_time >= now() - INTERVAL 15 MINUTE
GROUP BY 
    service_name, 
    operation_name
ORDER BY 
    request_count DESC`,
  expectedServices: ['frontend', 'currency', 'product-catalog'],
  analysisType: 'throughput',
  model: 'codellama'
}

/**
 * Shipping Calculator Flow Query - Real example from UI generation with error analysis
 */
export const shippingCalculatorQuery: DiagnosticQueryFixture = {
  id: 'shipping-calculator',
  name: 'Shipping Calculator Flow',
  description: 'Analyze shipping calculator errors and problematic traces',
  sql: `WITH problematic_traces AS (
    SELECT 
        trace_id
    FROM otel.traces
    WHERE service_name IN ('frontend', 'shipping', 'currency')
        AND status_code != 'OK'
        AND start_time >= now() - INTERVAL 15 MINUTE
)

SELECT 
    service_name,
    operation_name,
    count() AS request_count,
    countIf(status_code != 'OK') AS error_count,
    round(countIf(status_code != 'OK') * 100.0 / count(), 2) AS error_rate_pct,
    groupArray(10)(status_code) AS error_types,
    avg(duration_ns) / 1000000 AS avg_duration_ms,
    count(DISTINCT trace_id) AS affected_traces,
    count(DISTINCT trace_id) FILTER (WHERE trace_id IN (SELECT trace_id FROM problematic_traces)) AS traces_with_errors
FROM otel.traces
WHERE service_name IN ('frontend', 'shipping', 'currency')
    AND start_time >= now() - INTERVAL 15 MINUTE
GROUP BY service_name, operation_name
HAVING count() > 5 AND error_count > 0
ORDER BY error_rate_pct DESC, error_count DESC`,
  expectedServices: ['frontend', 'shipping', 'currency'],
  analysisType: 'errors',
  model: 'codellama'
}

/**
 * Fraud Detection Flow Query - Real example from UI generation with complex analysis
 */
export const fraudDetectionQuery: DiagnosticQueryFixture = {
  id: 'fraud-detection',
  name: 'Fraud Detection Flow',
  description: 'Analyze fraud detection service performance impact on critical path',
  sql: `WITH slowest_operations AS (
  SELECT 
    service_name, 
    operation_name,
    quantile(0.95)(duration_ns/1000000) as p95_ms,
    count() AS request_count
  FROM otel.traces
  WHERE 
    service_name IN ('payment', 'fraud-detection', 'accounting')
    AND start_time >= now() - INTERVAL 15 MINUTE
  GROUP BY service_name, operation_name
  HAVING count() > 5
  ORDER BY p95_ms DESC
  LIMIT 10
),
critical_path_impact AS (
  SELECT
    t.trace_id,
    so.service_name,
    so.operation_name,
    t.duration_ns/1000000 as duration_ms,
    t.duration_ns / sum(t.duration_ns) OVER (PARTITION BY t.trace_id) as fraction_of_trace
  FROM otel.traces t
  JOIN slowest_operations so ON t.service_name = so.service_name AND t.operation_name = so.operation_name
  WHERE 
    t.start_time >= now() - INTERVAL 15 MINUTE
)
SELECT
  service_name,
  operation_name,
  avg(duration_ms) as avg_duration_ms,
  quantile(0.5)(duration_ms) as p50_ms,
  quantile(0.95)(duration_ms) as p95_ms,
  quantile(0.99)(duration_ms) as p99_ms,
  avg(fraction_of_trace) as avg_trace_impact,
  count() as occurrence_count
FROM critical_path_impact
GROUP BY service_name, operation_name
ORDER BY avg_trace_impact DESC, p95_ms DESC`,
  expectedServices: ['payment', 'fraud-detection', 'accounting'],
  analysisType: 'bottlenecks',
  model: 'codellama'
}

/**
 * All diagnostic query fixtures for testing - Real queries from UI generation
 */
export const diagnosticQueries: DiagnosticQueryFixture[] = [
  checkoutFlowQuery,
  productSearchQuery,
  currencyConversionQuery,
  shippingCalculatorQuery,
  fraudDetectionQuery
]

/**
 * Get a query fixture by ID
 */
export function getQueryFixture(id: string): DiagnosticQueryFixture | undefined {
  return diagnosticQueries.find((q) => q.id === id)
}

/**
 * Get queries by analysis type
 */
export function getQueriesByType(
  type: DiagnosticQueryFixture['analysisType']
): DiagnosticQueryFixture[] {
  return diagnosticQueries.filter((q) => q.analysisType === type)
}
